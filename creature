#!/bin/sh
#
# 2010 Nico Schottelius (nico-creature at schottelius.org)
#
# This file is part of creature.
#
# creature is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# creature is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with creature. If not, see <http://www.gnu.org/licenses/>.
#
# Initially written for SyGroup (www.sygroup.ch)
# Date: Mon Nov 14 11:45:11 CET 2005

# Error upon expanding unset variables:
set -u

#
# Standard variables (stolen from cconf)
#
__pwd="$(pwd -P)"
__mydir="${0%/*}"; __abs_mydir="$(cd "$__mydir" && pwd -P)"
__myname=${0##*/}; __abs_myname="$__abs_mydir/$__myname"

#
# where to find our configuration and temporary file
#
CREATURE_CONF="${CREATURE_CONF:-/etc/creature}"
CPOOL="${CREATURE_CONF}/pools"
CDEFAULTS="${CREATURE_CONF}/defaults"
CPREEXEC="${CDEFAULTS}/pre_exec"
CPOSTEXEC="${CDEFAULTS}/post_exec"
CMARKER=".creature-marker"

export TMP="$(mktemp "/tmp/${__myname}.XXXXXX")"
VERSION="0.1"
RELEASE="2010-09-XX"
HALF_VERSION="creature ${VERSION}"
FULL_VERSION="creature ${VERSION} (${RELEASE})"

#
# CDATE: how we use it for naming of the archives
# DDATE: how the user should see it in our output (DISPLAY)
#
CDATE="date +%Y%m%d-%H%M"
DDATE="date +%Y-%m-%d-%H:%M:%S"
SDATE="date +%s"

COMMANDS="help pool_add version"
help_help="Show this help screen"
pool_add_help="<name> <path>: Create a new storage pool"
version_help="Print version information"


#!/bin/sh
# 
# 2009      Nico Schottelius (nico-sexy at schottelius.org)
# 
# This file is part of sexy.
#
# sexy is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# sexy is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with sexy. If not, see <http://www.gnu.org/licenses/>.
#
#
# Load the configuration - this script should be sourced
#

################################################################################
# standard vars stolen from cconf, renamed for sexy
__sexy_pwd="$(pwd -P)"
__sexy_mydir="${0%/*}"; __sexy_abs_mydir="$(cd "$__sexy_mydir" && pwd -P)"
__sexy_myname=${0##*/}; __sexy_abs_myname="$__sexy_abs_mydir/$__sexy_myname"


# where our database / components can be found
sexy_db="${sexy_db:-$HOME/.sexy}"
sexy_db_abs="$(cd "${sexy_db}" && pwd -P)"
sexy_default_config="${sexy_db_abs}/${sexy_config_path}"

#
# Determine the current configuration directory
# A very mysterious, powerfull expression:
# Use the sexy db base + config + # Remove the database path, add the sexy db base + config +  
#
sexy_my_config="${sexy_db_abs}/${__sexy_abs_mydir##$sexy_db_abs}/.config"
sexy_my_tmp="${sexy_db_abs}/tmp${__sexy_abs_mydir##$sexy_db_abs}"


sexy_objects="backends hosts networks"

for sexy_object in $sexy_objects; do
   # This is the same as
   # : ${sexy_path_backends:="backends"}
   # just for variable names
   eval \: \${sexy_path_${sexy_object}:="$sexy_object"}

   #
   # Create full path in db, like
   # sexy_db_backends="${sexy_db}/${sexy_path_networks}"
   #
   eval sexy_db_${sexy_object}="\"${sexy_db}/\${sexy_path_${sexy_object}}\""

   #
   # The path to the configuration (if available) for an object.
   #
   eval sexy_db_config_${sexy_object}="\"${sexy_db}/config/\${sexy_path_${sexy_object}}\""

   # Debug output
   # eval echo "\${sexy_db_${sexy_object}}"
done
sexy_object=""

# What cares about what
sexy_object_types="${sexy_path_hosts} ${sexy_path_networks}"
sexy_runner_known="${sexy_path_networks}"

################################################################################
# Convert fqdn to hostname
sexy_fqdn_to_hostname()
{
   sexy_host="$1"; shift
}

# Return if a host exists in a network
sexy_host_exists()
{
   sexy_network="$1"; shift
   sexy_host="$1"; shift

   if [ -d "$(sexy_object_path "${sexy_path_networks}" "${sexy_network}")/hosts/${sexy_host}" ]; then
      return 0
   else
      return 1
   fi
}

########## TYPES
# Return type path
sexy_type_path()
{
   sexy_type="$1"; shift

   eval echo \${sexy_db_${sexy_type}}
}


# Retrieve configuration for a type FIXME
sexy_type_attribute_get()
{
   sexy_type="$1"; shift
   sexy_attribute="$1"; shift

   cat "$(sexy_type_path "${sexy_type}")/.config/${sexy_attribute}"
}

# Retrieve configuration path for a type
sexy_type_config_path()
{
   sexy_type="$1"; shift
   sexy_config="$1"; shift

   echo "$(sexy_type_path "${sexy_type}")/.config/${sexy_config}"
}

# Retrieve configuration for a type
sexy_type_config_get()
{
   sexy_type="$1"; shift
   sexy_config="$1"; shift

   cat "$(sexy_type_config_path "${sexy_type}" "${sexy_config}")"
}

# Retrieve configuration for a type, failing is ok
sexy_type_config_failok_get()
{
   sexy_type="$1"; shift
   sexy_config="$1"; shift

   sexy_type_config_get "${sexy_type}" "${sexy_config}" 2>/dev/null || true
}


########## OBJECTS
# Retrieve configuration for an object
sexy_object_config_failok_get()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_config="$1"; shift

   sexy_object_config_get "${sexy_type}" "${sexy_object}" "${sexy_config}" 2>/dev/null || true
}

sexy_object_config_get()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_config="$1"; shift

   cat "$(sexy_object_config_path "${sexy_type}" "${sexy_object}" "${sexy_config}")"
}

# Add CONFIGURATION for an object
sexy_object_config_add()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_config="$1"; shift
   sexy_value="$1"; shift

   mkdir -p "$(sexy_object_config_path "${sexy_type}" "${sexy_object}" "")"
   echo "${sexy_value}" >> "$(sexy_object_config_path "${sexy_type}" "${sexy_object}" "${sexy_config}")"
}

# CONFIGUre configuration for an object
sexy_object_config_set()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_config="$1"; shift
   sexy_value="$1"; shift

   mkdir -p "$(sexy_object_config_path "${sexy_type}" "${sexy_object}" "")"
   echo "${sexy_value}" > "$(sexy_object_config_path "${sexy_type}" "${sexy_object}" "${sexy_config}")"
}

# Retrieve configuration path for an object
sexy_object_config_path()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_config="$1"; shift

   echo "$(sexy_type_path "${sexy_type}")/${sexy_object}/.config/${sexy_config}"
}

# Return attribute: object specific
sexy_object_attribute_get()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_attribute="$1"; shift

   cat "$(sexy_object_attribute_path "${type}" "${object}" "${attribute}")"
}


# Return object path
sexy_object_attribute_path()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_attribute="$1"; shift

   sexy_object_attribute_path="$(sexy_object_path "$sexy_type" "$sexy_object")/${sexy_attribute}"
   echo "${sexy_object_attribute_path}"
}

# Return if object exists or not
sexy_object_attribute_exists()
{
   type="$1"; shift
   object="$1"; shift
   attribute="$1"; shift

   if [ -d "$(sexy_object_attribute_path "${type}" "${object}" "${attribute}")" ]; then
      return 0
   else
      return 1
   fi
}

# Return object path
sexy_object_path()
{
   type="$1"; shift
   object="$1"; shift

   echo "$(sexy_type_path "${type}")/${object}"
}

# Return if object exists or not
sexy_object_exists()
{
   type="$1"; shift
   object="$1"; shift

   if [ -d "$(sexy_object_path "${type}" "${object}")" ]; then
      return 0
   else
      return 1
   fi
}

# Return one byte of an ipv4 address
sexy_ipv4_get_byte()
{
   sexy_ipv4_addr="$1"; shift
   sexy_byte_num="$1"; shift

   echo "$sexy_ipv4_addr" | cut -d. "-f${sexy_byte_num}"
}

# Increment given ipv4 address by one
sexy_ipv4_addr_increment()
{
   sexy_ipv4_addr="$1"; shift

   sexy_i="4"
   sexy_ipv4_added="0"
   sexy_ipv4_addr_new=""

   while [ $sexy_i -ge 1 ]; do
      sexy_ipv4_byte=$(sexy_ipv4_get_byte $sexy_ipv4_addr ${sexy_i})

      if [ $sexy_ipv4_added -eq 0 ]; then
         if [ $((${sexy_ipv4_byte} + 1)) -gt 255 ]; then
            sexy_ipv4_byte="0"
         else
            sexy_ipv4_byte=$((${sexy_ipv4_byte} + 1))
            sexy_ipv4_added="1"
         fi
      fi

      sexy_ipv4_addr_new="${sexy_ipv4_byte}${sexy_ipv4_addr_new}"
      [ $sexy_i -gt 1 ] && sexy_ipv4_addr_new=".${sexy_ipv4_addr_new}"

      sexy_i=$(($sexy_i - 1))
   done

   echo $sexy_ipv4_addr_new
}

# Convert netmask from bitmask to decimal
sexy_network_decimal_netmask()
{
   sexy_mask_rest="$1"; shift
   sexy_decimal_mask="";
   sexy_i="0"

   while [ $sexy_i -lt 4 ]; do
      if [ "$(($sexy_mask_rest / 8))" -ge 1 ]; then
         byte=255
         sexy_mask_rest="$(($sexy_mask_rest-8))"
      else
         inc=128
         byte=0
         while [ $sexy_mask_rest -gt 0 ]; do
            byte=$(($byte + $inc))
            inc=$(($inc / 2))
            sexy_mask_rest=$(($sexy_mask_rest-1))
         done
      fi  

      sexy_decimal_mask="${sexy_decimal_mask}${byte}"

      sexy_i=$(($sexy_i + 1))

      [ $sexy_i -lt 4 ] && sexy_decimal_mask="${sexy_decimal_mask}."
   done

   echo $sexy_decimal_mask
}

# Calculate broadcast for subnet
sexy_network_decimal_broadcast()
{
   sexy_network="$1"; shift
   sexy_mask_rest="$1"; shift
   sexy_decimal_broadcast="";
   sexy_i="0"

   while [ "${sexy_i}" -lt 4 ]; do
      if [ "$(($sexy_mask_rest / 8))" -ge 1 ]; then
         sexy_netmask_byte=255
         sexy_mask_rest="$(($sexy_mask_rest-8))"
      else
         sexy_netmask_byte=0
         inc=128
         while [ $sexy_mask_rest -gt 0 ]; do
            sexy_netmask_byte=$(($sexy_netmask_byte + $inc))
            inc=$(($inc / 2))
            sexy_mask_rest=$(($sexy_mask_rest-1))
         done
      fi  
 
      sexy_current_field="$(sexy_ipv4_get_byte $sexy_network $(($sexy_i+1)))"
      sexy_current_broadcast="$(($sexy_current_field | ($sexy_netmask_byte ^ 255)))"

      sexy_decimal_broadcast="${sexy_decimal_broadcast}${sexy_current_broadcast}"

      sexy_i=$(($sexy_i + 1))

      [ $sexy_i -lt 4 ] && sexy_decimal_broadcast="${sexy_decimal_broadcast}."
   done

   echo $sexy_decimal_broadcast
}

# Share a temp file (within a backend for instance)
sexy_shared_temp()
{
   set -e
   sexy_temp_name="tempfile"

   [ "$1" ]; sexy_temp_name="${sexy_temp_name}-$1"
   sexy_tempfile="${sexy_my_tmp}/${sexy_temp_name}"
   mkdir -p "${sexy_my_tmp}"
   touch "${sexy_tempfile}"
   echo "${sexy_tempfile}"
}

# the secure variant
sexy_mktemp()
{
   set -e
   mkdir -p "${sexy_my_tmp}"
   mktemp "${sexy_my_tmp}/tempfile.XXXXXXXXXXXXXXX"
}

# Write message, prefixed by scriptname
sexy_msg()
{
   echo "${__sexy_myname}: $@"
}

sexy_errormsg()
{
   sexy_msg "$@"
   exit 1
}

# argument(s) should not be empty
sexy_notempty()
{
   errormsg="$1"; shift

   while [ "$#" -gt 0 ]; do
      if [ "$1" ]; then
         shift
      else
         sexy_errormsg "$errormsg"
      fi
   done
}

# read a file with error handling
sexy_file_read()
{
   sexy_file="$1"; shift

   cat "${sexy_file}" || sexy_errormsg "Cannot read file ${sexy_file}"

}

# Have a look whether there are optional parameters left
sexy_args_optional()
{

   # sexy_args ran before, skip already checked items
   if [ "${sexy_args_next}" ]; then
      echo "Skipping $sexy_args_next ..."
      shift "${sexy_args_next}"
   fi


}

# Require some command line parameters and allow optional parameters
# -atleast: have at least the given number of arguments, but allow more to be present
# -exact: have exactly the given number of arguments
# -optional: allow arguments to be missing
# -skip: skip previously found arguments
sexy_args()
{
   count=0
   arglist=""
   sexy_args_exact="exact"
   sexy_args_skip="1"

   # get argument list
   while [ "$#" -gt 0 ]; do
      case "$1" in
         # Only allow exact number of arguments (normally allow more)
         -atleast)
            sexy_args_exact="atleast"
            shift
         ;;
         -optional)
            sexy_args_exact="optional"
            shift
         ;;
         # Skip previously found parameters
         -skip)
            sexy_args_skip="$(($sexy_args_skip+$sexy_args_next))"
            shift
         ;;
         -*)
            sexy_errormsg "Unknown sexy argument"
            shift
         ;;
         *)
            break
         ;;
      esac
   done

   # get argument list
   while [ "$1" != "--" ]; do
      eval arg_${count}=\"$1\"
      # unset
      eval $1=""
      arglist="$arglist $1"
      shift
      count=$(($count+1))
   done
 
   # skip at the "--" or more args if -skip is specified
   shift $sexy_args_skip

   # Need the exact number of arguments
   if [ "${sexy_args_exact}" = "exact" -a "$#" -ne "$count" ]; then
      sexy_errormsg ${arglist}
   # Need at least given number of arguments
   elif [ "${sexy_args_exact}" = "atleast" -a "$#" -lt "$count" ]; then
      sexy_errormsg ${arglist}
   fi

   # assign values
   export sexy_args_next=0
   while [ "$#" -gt 0 -a "$sexy_args_next" -lt "${count}" ]; do
      eval export \$arg_$sexy_args_next=\"$1\"
      shift
      sexy_args_next=$(($sexy_args_next+1))
   done
}

help()
{
   cat << eof
${__myname}: <command> <options>

   creature manages virtual monsters

eof

   for cmd in $COMMANDS; do
      eval text=\"\$${cmd}_help\"
      echo "   ${cmd}: ${text}"
   done

   cat << eof

   This is version ${VERSION}, released on ${RELEASE}
   (the first version was written on 2010-09-ZZ by Nico Schottelius).

   Retrieve latest creature at http://www.nico.schottelius.org/software/creature/
eof
   exit 0
}

pool_add()
{
   name="$1"
   location="$1"

   pool_dir="${CPOOL}/${name}"

   mkdir -p "${pool_dir}"
   echo "${location}, > 
   
}


version()
{
   echo "${FULL_VERSION}"
   exit 0
}

# "Main"
[ "$#" -gt 0 ] || help
cmd="$1"

case "$cmd" in
   version)
      shift; $cmd "$@"
   ;;
   *)
      help
   ;;
esac

# no code beyond here is useful so far
exit 0

#
# unset values
#
PARALLEL=""
USE_ALL=""

#
# catch signals
#
trap "rm -f \"${TMP}\"" 1 2 15

#
# Functions
#

# time displaying echo
_techo()
{
   echo "$(${DDATE}): $@"
}

# exit on error
_exit_err()
{
   _techo "$@"
   rm -f "${TMP}"
   exit 1
}

add_name()
{
   awk "{ print \"[${name}] \" \$0 }"
}

#
# Prepend "ssh ${remote_host}", if backing up to a remote host
#
pcmd()
{
   [ "${remote_host}" ] && set -- "ssh" "${remote_host}" "$@"

   "$@"
}

#
# ssh-"feature": we cannot do '... read ...; ssh  ...; < file',
# because ssh reads stdin! -n does not work -> does not ask for password
# Also allow deletion for files without the given suffix
#
delete_from_file()
{
   file="$1"; shift
   suffix="" # It will be set, if deleting incomplete backups.
   [ $# -eq 1 ] && suffix="$1" && shift
   while read to_remove; do
      set -- "$@" "${to_remove}"
      if [ "${suffix}" ]; then
         to_remove_no_suffix="$(echo ${to_remove} | sed "s/$suffix\$//")"
         set -- "$@" "${to_remove_no_suffix}"
      fi
   done < "${file}"
   _techo "Removing $@ ..."
   [ "${VVERBOSE}" ] && echo rm "$@"
   pcmd rm -rf "$@" || _exit_err "Removing $@ failed."
}


#
# Setup interval
#
if [ $# -ge 1 ]; then
   export INTERVAL="$1"
   shift
else
   usage
fi

#
# Check for configuraton directory
#
[ -d "${CREATURE_CONF}" ] || _exit_err "No configuration found in " \
   "\"${CREATURE_CONF}\" (is \$CREATURE_CONF properly set?)"

#
# Create (portable!) source "array"
#
export no_sources=0

if [ "${USE_ALL}" = 1 ]; then
   #
   # Get sources from source configuration
   #
   ( cd "${CSOURCES}" && ls -1 > "${TMP}" ) || \
      _exit_err "Listing of sources failed. Aborting."

   while read tmp; do
      eval export source_${no_sources}=\"${tmp}\"
      no_sources=$((${no_sources}+1))
   done < "${TMP}"
else
   #
   # Get sources from command line
   #
   while [ "$#" -ge 1 ]; do
      eval arg=\"\$1\"; shift

      eval export source_${no_sources}=\"${arg}\"
      no_sources="$((${no_sources}+1))"
   done
fi

#
# Need at least ONE source to backup
#
if [ "${no_sources}" -lt 1 ]; then
   usage
else
   _techo "${HALF_VERSION}: Beginning backup using interval ${INTERVAL}"
fi

#
# Look for pre-exec command (general)
#
if [ -x "${CPREEXEC}" ]; then
   _techo "Executing ${CPREEXEC} ..."
   "${CPREEXEC}"; ret=$?
   _techo "Finished ${CPREEXEC} (return code: ${ret})."

   [ "${ret}" -eq 0 ] || _exit_err "${CPREEXEC} failed. Aborting"
fi

################################################################################
#
# Let's do the backup - here begins the real stuff
#
source_no=0
while [ "${source_no}" -lt "${no_sources}" ]; do
   #
   # Get current source
   #
   eval export name=\"\$source_${source_no}\"
   source_no=$((${source_no}+1))

   #
   # Start ourself, if we want parallel execution
   #
   if [ "${PARALLEL}" ]; then
      "$0" "${INTERVAL}" "${name}" &
      continue
   fi

#
# Start subshell for easy log editing
#
(
   backup="${CSOURCES}/${name}"
   c_source="${backup}/source"
   c_dest="${backup}/destination"
   c_pre_exec="${backup}/pre_exec"
   c_post_exec="${backup}/post_exec"

   #
   # Stderr to stdout, so we can produce nice logs
   #
   exec 2>&1

   #
   # Record start of backup: internal and for the user
   #
   begin_s="$(${SDATE})"
   _techo "Beginning to backup"

   #
   # Standard configuration checks
   #
   if [ ! -e "${backup}" ]; then
      _exit_err "Source does not exist."
   fi

   #
   # Configuration _must_ be a directory (cconfig style)
   #
   if [ ! -d "${backup}" ]; then
      _exit_err "\"${backup}\" is not a cconfig-directory. Skipping."
   fi

   #
   # First execute pre_exec, which may generate destination or other parameters
   #
   if [ -x "${c_pre_exec}" ]; then
      _techo "Executing ${c_pre_exec} ..."
      "${c_pre_exec}"; ret="$?"
      _techo "Finished ${c_pre_exec} (return code ${ret})."

      [ "${ret}" -eq 0 ] || _exit_err "${c_pre_exec} failed. Skipping."
   fi

   #
   # Read source configuration
   #
   for opt in verbose very_verbose summary exclude rsync_options \
              delete_incomplete remote_host rsync_failure_codes  \
              mtime quiet_if_down ; do
      if [ -f "${backup}/${opt}" -o -f "${backup}/no_${opt}"  ]; then
         eval c_$opt=\"${backup}/$opt\"
      else
         eval c_$opt=\"${CDEFAULTS}/$opt\"
      fi
   done

   #
   # Interval definition: First try source specific, fallback to default
   #
   c_interval="$(cat "${backup}/intervals/${INTERVAL}" 2>/dev/null)"

   if [ -z "${c_interval}" ]; then
      c_interval="$(cat "${CDEFAULTS}/intervals/${INTERVAL}" 2>/dev/null)"

      if [ -z "${c_interval}" ]; then
         _exit_err "No definition for interval \"${INTERVAL}\" found. Skipping."
      fi
   fi

   #
   # Sort by ctime (default) or mtime (configuration option)
   #
   if [ -f "${c_mtime}" ] ; then
      TSORT="t"
   else
      TSORT="tc"
   fi

   #
   # Source configuration checks
   #
   if [ ! -f "${c_source}" ]; then
      _exit_err "Source description \"${c_source}\" is not a file. Skipping."
   else
      source=$(cat "${c_source}"); ret="$?"
      if [ "${ret}" -ne 0 ]; then
         _exit_err "Source ${c_source} is not readable. Skipping."
      fi
   fi

   #
   # Destination is a path
   #
   if [ ! -f "${c_dest}" ]; then
      _exit_err "Destination ${c_dest} is not a file. Skipping."
   else
      ddir="$(cat "${c_dest}")"; ret="$?"
      if [ "${ret}" -ne 0 ]; then
         _exit_err "Destination ${c_dest} is not readable. Skipping."
      fi
   fi

   #
   # Set pre-cmd, if we backup to a remote host.
   #
   if [ -f "${c_remote_host}" ]; then
      remote_host="$(cat "${c_remote_host}")"; ret="$?"
      if [ "${ret}" -ne 0 ]; then
         _exit_err "Remote host file ${c_remote_host} is unreadable. Skipping."
      fi
      destination="${remote_host}:${ddir}"
   else
      remote_host=""
      destination="${ddir}"
   fi
   export remote_host

   #
   # Parameters: creature defaults, configuration options, user options
   #

   #
   # Rsync standard options
   #
   set -- "$@" "--archive" "--delete" "--numeric-ids" "--relative"   \
               "--delete-excluded" "--sparse"

   #
   # Exclude list
   #
   if [ -f "${c_exclude}" ]; then
      set -- "$@" "--exclude-from=${c_exclude}"
   fi

   #
   # Output a summary
   #
   if [ -f "${c_summary}" ]; then
      set -- "$@" "--stats"
   fi

   #
   # Verbosity for rsync, rm, and mkdir
   #
   VVERBOSE=""
   if [ -f "${c_very_verbose}" ]; then
      set -- "$@" "-vv"
      VVERBOSE="-v"
   elif [ -f "${c_verbose}" ]; then
      set -- "$@" "-v"
   fi

   #
   # Extra options for rsync provided by the user
   #
   if [ -f "${c_rsync_options}" ]; then
      while read line; do
         set -- "$@" "${line}"
      done < "${c_rsync_options}"
   fi

   #
   # Check: source is up and accepting connections (before deleting old backups!)
   #
   if ! rsync "$@" "${source}" >/dev/null 2>"${TMP}" ; then
      if [ ! -f "${c_quiet_if_down}" ]; then
         cat "${TMP}"
      fi
      _exit_err "Source ${source} is not readable. Skipping."
   fi

   #
   # Check: destination exists?
   #
   ( pcmd cd "${ddir}" ) || _exit_err "Cannot change to ${ddir}. Skipping."

   #
   # Check: incomplete backups? (needs echo to remove newlines)
   #
   # *.marker: not possible, creates an error, if no *.marker exists
   # -> catch return value

   pcmd ls -d1 "${ddir}/"*"${CMARKER}" > "${TMP}" 2>/dev/null; ret=$?

   if [ "${ret}" -eq 0 ]; then
      _techo "Incomplete backups: $(echo $(cat "${TMP}"))"
      if [ -f "${c_delete_incomplete}" ]; then
         delete_from_file "${TMP}" "${CMARKER}"
      fi
   fi

   #
   # Check: maximum number of backups is reached?
   #
   count="$(pcmd ls -d1 "${ddir}/${INTERVAL}."*"/" | wc -l | sed 's/^ *//g')" \
      || _exit_err "Counting backups failed"

   _techo "Existing backups: ${count} Total keeping backups: ${c_interval}"

   if [ "${count}" -ge "${c_interval}" ]; then
      substract="$((${c_interval} - 1))"
      remove="$((${count} - ${substract}))"
      _techo "Removing ${remove} backup(s)..."

      pcmd ls -${TSORT}d1r "${ddir}/${INTERVAL}."*"/" |
         head -n "${remove}" > "${TMP}"      || \
            _exit_err "Listing old backups failed"

      delete_from_file "${TMP}"
   fi

   #
   # Check for backup directory to clone from: Always clone from the latest one!
   #
   last_dir="$(pcmd ls -${TSORT}p1 "${ddir}" | grep '/$' | head -n 1)" || \
      _exit_err "Failed to list contents of ${ddir}."

   #
   # Clone from old backup, if existing
   #
   if [ "${last_dir}" ]; then
      set -- "$@" "--link-dest=${ddir}/${last_dir}"
      _techo "Hard linking from ${last_dir}"
   fi

   #
   # Include current time in name, not the time when we began to remove above
   #
   export destination_name="${INTERVAL}.$(${CDATE}).$$-${source_no}"
   export destination_dir="${ddir}/${destination_name}"
   export destination_full="${destination}/${destination_name}"

   _techo "Creating directory ${destination_dir} ..."
   [ "${VVERBOSE}" ] && echo "mkdir ${destination_dir}" 
   pcmd mkdir "${destination_dir}" || \
      _exit_err "Creating directory ${destination_dir} failed. Skipping."

   #
   # added marking in 0.6 (and remove it, if successful later)
   #
   pcmd touch "${destination_dir}${CMARKER}"

   #
   # the rsync part
   #
   _techo "Transferring files..."
   rsync "$@" "${source}" "${destination_full}"; ret=$?
   _techo "Finished backup (rsync return code: $ret)."

   #
   # Set modification time (mtime) to current time, if sorting by mtime is enabled
   #
   [ -f "$c_mtime" ] && pcmd touch "${destination_dir}"

   #
   # Check if rsync exit code indicates failure.
   #
   fail=""
   if [ -f "$c_rsync_failure_codes" ]; then
      while read code ; do
         if [ "$ret" = "$code" ]; then
            fail=1
         fi
      done <"${c_rsync_failure_codes}"
   fi

   #
   # Remove marking here unless rsync failed.
   #
   if [ -z "$fail" ]; then
      pcmd rm "${destination_dir}${CMARKER}" || \
         _exit_err "Removing ${destination_dir}${CMARKER} failed."
      if [ "${ret}" -ne 0 ]; then
         _techo "Warning: rsync exited non-zero, the backup may be broken (see rsync errors)."
      fi
   else
      _techo "Warning: rsync failed with return code $ret."
   fi

   #
   # post_exec
   #
   if [ -x "${c_post_exec}" ]; then
      _techo "Executing ${c_post_exec} ..."
      "${c_post_exec}"; ret=$?
      _techo "Finished ${c_post_exec}."

      if [ "${ret}" -ne 0 ]; then
         _exit_err "${c_post_exec} failed."
      fi
   fi

   #
   # Time calculation
   #
   end_s="$(${SDATE})"
   full_seconds="$((${end_s} - ${begin_s}))"
   hours="$((${full_seconds} / 3600))"
   minutes="$(((${full_seconds} % 3600) / 60))"
   seconds="$((${full_seconds} % 60))"

   _techo "Backup lasted: ${hours}:${minutes}:${seconds} (h:m:s)"
) | add_name
done

#
# Be a good parent and wait for our children, if they are running wild parallel
#
if [ "${PARALLEL}" ]; then
   _techo "Waiting for children to complete..."
   wait
fi

#
# Look for post-exec command (general)
#
if [ -x "${CPOSTEXEC}" ]; then
   _techo "Executing ${CPOSTEXEC} ..."
   "${CPOSTEXEC}"; ret=$?
   _techo "Finished ${CPOSTEXEC} (return code: ${ret})."

   if [ "${ret}" -ne 0 ]; then
      _techo "${CPOSTEXEC} failed."
   fi
fi

rm -f "${TMP}"
_techo "Finished"
